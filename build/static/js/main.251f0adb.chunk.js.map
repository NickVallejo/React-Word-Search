{"version":3,"sources":["scripts/wizard.js","components/AppWrap.jsx","components/AppInfo.jsx","components/search-box/InputBox.jsx","components/search-box/SearchWrap.jsx","components/search-box/WordResult.jsx","helpers/matrixTranslate.js","components/search-box/WordSearch.jsx","components/LoadingScreen.jsx","App.jsx","index.js"],"names":["letterMatrix","dic","uniqueArrays","letterObj","letterGen","a","i","letterInQ","String","fromCharCode","letters","filter","el","startsWith","genGrid","gridSize","sqrtSize","Math","sqrt","counter","Array","from","length","e","forEach","row","rowIndex","col","colIndex","wordFetch","fetch","dictionary","text","split","word","displayResults","resMap","res","uniqueWord","map","obj","letter","join","some","push","path","wordSearch","posX","posY","j","index","thePath","JSON","parse","stringify","toUpperCase","lettersPlusNewPath","firstLetter","charAt","foundStart","find","trim","appConfig","AppWrap","props","className","loader","children","AppInfo","genReady","genStart","useEffect","console","log","disabled","onClick","InputBox","activeIndex","moveHandler","cords","hoveredPath","inputRef","useRef","useState","input","setInput","match","setMatch","current","focus","toString","classNames","boxCordIndex","findIndex","cordArray","parseInt","undefined","nextRow","nextCol","determineDirection","name","ref","value","type","onKeyDown","key","onChange","target","SearchWrap","WordResult","passUpPathHovered","passUpPathRemoved","onMouseOut","onMouseOver","matrix4x4","WordSearch","srcSize","readySetter","wordRes","setActiveIndex","fill","letterArray","setLetterArray","setHoveredPath","wordCount","setWordCount","every","modLetters","mod","prevLetters","mutLetters","splice","dir","prevIndex","wordCountTxt","LoadingScreen","dots","setDots","loadingProg","setLoadingProg","document","addEventListener","progLoader","adder","prevProg","Promise","resolve","setTimeout","dotLength","style","width","App","setGenReady","setLetters","setWordRes","setLoader","words","ready","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.251f0adb.chunk.js","sourcesContent":["let letterMatrix\r\nlet dic\r\nlet wordDisplay = []\r\nlet uniqueArrays = []\r\nlet letterObj = {}\r\n\r\n// iterates through the alphabet using charcodes and groups all letters\r\n// into their own array, determined by the letter they start with\r\n// eg. letterObj['G'] = [array filled with all letters starting with G]\r\n// used to search the dictionary more efficiently\r\nexport const letterGen = async() => {\r\n    for(let i = 65; i <= 90; i++){\r\n        const letterInQ = String.fromCharCode(i)\r\n        const letters = dic.filter(el => el.startsWith(letterInQ))\r\n        letterObj[letterInQ] = letters\r\n    }\r\n}\r\n\r\nexport const genGrid = (gridSize, letters) => {\r\n    const sqrtSize = Math.sqrt(gridSize)\r\n    let counter = 0\r\n    \r\n    //make a square 2d array\r\n    letterMatrix = Array.from({length: sqrtSize}, e => \r\n        Array.from({length: sqrtSize}, e => ''))\r\n\r\n    //fill each position with the letters of inputted by user\r\n    letterMatrix.forEach((row, rowIndex) => {\r\n        row.forEach((col, colIndex) => {\r\n            letterMatrix[rowIndex][colIndex] = letters[counter]\r\n            counter++\r\n        })\r\n    })\r\n\r\n    return letterMatrix\r\n}\r\n\r\n// fetches the dictionary.txt file, line breaks each word and removes\r\n// words that are 2 letters or less\r\nexport const wordFetch = async() => {\r\n    const dictionary = await fetch('dictionary.txt')\r\n    dic = await dictionary.text()\r\n    dic = dic.split(\"\\r\\n\")\r\n    dic = dic.filter(word => word.length > 2)\r\n}\r\n\r\nexport const displayResults = () => {\r\n    let resMap = []\r\n    uniqueArrays.forEach(res => {\r\n        const uniqueWord = res.map(obj => obj.letter).join('')\r\n        if(resMap.some(el => el.word == uniqueWord) === false){\r\n            resMap.push({word: uniqueWord, path: res.map(obj => [obj.row, obj.col])})\r\n        }\r\n    })\r\n    return resMap\r\n}\r\n\r\nexport const clearPreviousWords = () => {\r\n    wordDisplay = []\r\n    uniqueArrays = []\r\n    console.log(uniqueArrays, 'WIZARD ARRAY RESET')\r\n}\r\n\r\nexport const wordSearch = (path=[], letterMatrix) => {\r\n    //grabs the last letter pushed into the path array, gets it's row and col props\r\n    let posX = path[path.length - 1].row\r\n    let posY = path[path.length - 1].col\r\n\r\n    //this loop allows us to search every direction surrounding the letter in question\r\n    for(const i of [-1, 0, 1]){\r\n        for(const j of [-1, 0, 1]){\r\n            //if i  & j both = 0, we are trying to search the coord we're currently on\r\n            if (i === 0 && j === 0) continue;\r\n            let row = posX + i\r\n            let col = posY + j\r\n    \r\n            //continues if there is a value outside the bounds of the 2d array\r\n            if (row < 0 || col < 0 || row >= 4 || col >= 4) continue\r\n            //continues if the letter in question is already in the path\r\n            if(path.some(index => index.row == row && index.col == col )) continue\r\n\r\n            \r\n            let foundWord = false;\r\n            //create a new instance of the path\r\n            const thePath = JSON.parse(JSON.stringify(path));\r\n            //create the word formed by the path (no cords, just the letters in this array)\r\n            const newPathLetters = thePath.map(obj => obj.letter)\r\n            //join the letters in the array defined in newpathletters (creates string)\r\n            const letters = newPathLetters.join('').toUpperCase()\r\n            //append the latest letter onto the word string\r\n            const lettersPlusNewPath = letters+letterMatrix[row][col].toUpperCase()\r\n            //get the first letter of the word\r\n            const firstLetter = lettersPlusNewPath.charAt(0)\r\n            //check if there is a word in the dictionary that starts with the string we created\r\n            const foundStart = letterObj[firstLetter].find(word => word.startsWith(lettersPlusNewPath))\r\n\r\n            //if no word starts with this collection of letters, try the next letter adjacent \r\n            //to the latest point in the path\r\n            if(!foundStart) {\r\n                continue\r\n            } else{\r\n                //if a word does start with this collection of letters, push the path of the new letter into the path object\r\n                thePath.push({letter: letterMatrix[row][col], row: row, col: col })\r\n                //does the word we created not only start with the found word, but also = it? we found a word!\r\n                foundWord = letters+letterMatrix[row][col].toUpperCase().trim() == foundStart.trim() ? true : false\r\n                //push the found word to the uniquearray and continue the search\r\n                foundWord && uniqueArrays.push(thePath)\r\n                wordSearch(thePath, letterMatrix)\r\n            }\r\n        }\r\n    }\r\n\r\n    //return uniqueArrays\r\n} \r\n\r\nexport const appConfig = async() => {\r\n    await wordFetch()\r\n    letterGen()\r\n} \r\n","import React from 'react'\r\n\r\nfunction AppWrap(props) {\r\n    return (\r\n        <section className={`app-wrap ${props.loader && 'click-off'}`}>\r\n           {props.children} \r\n        </section>\r\n    )\r\n}\r\n\r\nexport default AppWrap\r\n","import React, {useEffect} from 'react'\r\n\r\nfunction AppInfo({genReady, genStart}) {\r\n\r\n    useEffect(() => {\r\n        console.log(genReady)\r\n    }, [genReady])\r\n\r\n    return (\r\n        <div className='app-info'>\r\n            <h1 className='proj-title'>Word Search <span>Wizard</span></h1>\r\n            <p className='proj-desc'>Type in a random set of letters and watch the word search do the rest.</p>\r\n            <button className=\"proj-btn\" disabled={!genReady} onClick={genStart}>Generate</button>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default AppInfo\r\n","import React, {useRef, useState, useEffect} from 'react'\r\n\r\nfunction InputBox({index, activeIndex, moveHandler, cords, hoveredPath}) {\r\n\r\n    const inputRef = useRef()\r\n    const [input, setInput] = useState('')\r\n    //! PATH IS AN ARRAY AND CORDS IS A STRING\r\n    const [match, setMatch] = useState(false)\r\n\r\n    useEffect(() => {\r\n        \r\n    }, [match])\r\n\r\n    useEffect(() => {\r\n        index === activeIndex && inputRef.current.focus()\r\n        console.log('CORDS', cords, 'HOVERED PATH', hoveredPath, 'MATCHED?', match)\r\n        if(hoveredPath.length > 0 && hoveredPath.some(path => path.toString() == cords)){\r\n            setMatch(true)\r\n        } else{\r\n            setMatch(false)\r\n        }\r\n    }, [activeIndex, hoveredPath, cords])\r\n\r\n    const keyDownHandler = (e) => {\r\n            if(e.key.match(/^[A-Za-z]+$/) && e.key.length === 1){\r\n                setInput(e.key.toUpperCase())\r\n            }\r\n    \r\n            if(e.key === \"Backspace\"){\r\n                moveHandler('prev', index)\r\n                setInput('')\r\n            }\r\n    }\r\n\r\n    const changeHandler = (e) => {\r\n        if(e.target.value.match(/^[A-Za-z]+$/)){\r\n            moveHandler('next', index, input)\r\n        }\r\n    }\r\n\r\n    const determineDirection = () => {\r\n        const boxCordIndex = hoveredPath.findIndex(path => path.toString() == cords)\r\n\r\n        if(boxCordIndex !== -1){\r\n            const cordArray = cords.split(',')\r\n            const row = parseInt(cordArray[0]);\r\n            const col = parseInt(cordArray[1]);\r\n            if(hoveredPath[boxCordIndex+1] == undefined) return ''\r\n            const nextRow = hoveredPath[boxCordIndex+1][0]\r\n            const nextCol = hoveredPath[boxCordIndex+1][1]\r\n\r\n            console.log(`cord array`, row, col, 'path', hoveredPath, 'next rows and cols', nextRow, nextCol)\r\n    \r\n            if(nextRow == row && nextCol == col+1) return `dirshow-e`\r\n            if(nextRow == row+1 && nextCol == col) return `dirshow-s`\r\n            if(nextRow == row+1 && nextCol == col+1) return `dirshow-se`\r\n            if(nextRow == row-1 && nextCol == col+1) return `dirshow-ne`\r\n            if(nextRow == row && nextCol == col-1 ) return `dirshow-w`\r\n            if(nextRow == row-1 && nextCol == col) return `dirshow-n`\r\n            if(nextRow == row-1 && nextCol == col-1) return `dirshow-nw`\r\n            if(nextRow == row+1 && nextCol == col-1) return `dirshow-sw`\r\n        }\r\n    }\r\n\r\n    const classNames = match ? determineDirection() : ''\r\n\r\n    return (\r\n        <div className={`input-box-${index}`} >\r\n            <div className={`dir ${classNames}`}></div>\r\n            <input\r\n            name={`field-${index}`}\r\n            ref={inputRef}\r\n            value={input} \r\n            type=\"text\"\r\n            onKeyDown={keyDownHandler} \r\n            onChange={changeHandler}\r\n            onClick={() => moveHandler('change', index)}\r\n            />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default InputBox","import React from 'react'\r\n\r\nfunction SearchWrap(props) {\r\n    return (\r\n        <div className='src-wizard-hero'>\r\n            {props.children}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default SearchWrap\r\n","import React from 'react'\r\n\r\nfunction WordResult({word, path, passUpPathHovered, passUpPathRemoved}) {\r\n \r\n    const showPath = () => {\r\n        passUpPathHovered(path)\r\n    }\r\n\r\n    return (\r\n        <div className={`word-res`} onMouseOut={passUpPathRemoved} onMouseOver={showPath}>\r\n            <h6>{word}</h6>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default WordResult","export const matrix4x4 = [\r\n'0,0','0,1','0,2','0,3',\r\n'1,0','1,1','1,2','1,3',\r\n'2,0','2,1','2,2','2,3',\r\n'3,0','3,1','3,2','3,3',\r\n]","import React, {useState, useEffect} from 'react'\r\nimport InputBox from './InputBox'\r\nimport SearchWrap from './SearchWrap'\r\nimport WordResult from './WordResult'\r\nimport {matrix4x4} from '../../helpers/matrixTranslate'\r\n\r\nfunction WordSearch({srcSize, readySetter, wordRes}) {\r\n    const [activeIndex, setActiveIndex] = useState(0)\r\n    const [letterArray, setLetterArray] = useState(Array(srcSize).fill(''))\r\n    const [hoveredPath, setHoveredPath] = useState([])\r\n    const [wordCount, setWordCount] = useState()\r\n\r\n    useEffect(() => {\r\n        console.log('WORDRES CHANGE', wordRes)\r\n        wordRes && setWordCount(wordRes.length)\r\n    }, [wordRes])\r\n\r\n    useEffect(() => {\r\n        readySetter(letterArray.every(el => el !== ''), letterArray);\r\n    }, [letterArray])\r\n\r\n    const modLetters = (index, mod) => {\r\n        setLetterArray(prevLetters => {\r\n            const mutLetters = Array.from(prevLetters)\r\n            mutLetters.splice(index, 1, mod)\r\n            return mutLetters\r\n        })\r\n    }\r\n\r\n    const moveHandler = (dir, index, input='') => {\r\n       console.log(activeIndex)\r\n       switch(dir){\r\n           case 'prev':\r\n               if(activeIndex === 0) return\r\n               modLetters(index, input)\r\n               setActiveIndex(prevIndex => prevIndex-=1)\r\n               break\r\n           case 'next':\r\n               modLetters(index, input)\r\n               if(activeIndex === srcSize+1) return\r\n               setActiveIndex(prevIndex => prevIndex+=1)\r\n               break\r\n            case 'change':\r\n                setActiveIndex(index)\r\n                break\r\n       }\r\n    }\r\n\r\n    const passUpPathHovered = (path) => {setHoveredPath(path)}\r\n    const passUpPathRemoved = () => {setHoveredPath([])}\r\n\r\n    let wordCountTxt = '';\r\n    if(wordCount > 0) wordCountTxt = <h3 className=\"word-count\">This many words found: <span className=\"count\">{wordCount}</span></h3>\r\n    if(wordCount === 0) wordCountTxt = <h3 className=\"word-count\">No words found!</h3>\r\n\r\n    return (\r\n        <SearchWrap>\r\n            {wordCountTxt}\r\n            <div className='search-box'>\r\n                {letterArray.length && letterArray.map( (el, index) => {\r\n                    return <InputBox\r\n                    key={index} \r\n                    index={index}\r\n                    cords={matrix4x4[index]} \r\n                    activeIndex={activeIndex}\r\n                    hoveredPath={hoveredPath} \r\n                    moveHandler={moveHandler} />\r\n                })}\r\n            </div>\r\n            <div className=\"search-results\">\r\n                {(wordRes && wordRes.length > 0) && wordRes.map(el => {\r\n                    return <WordResult key={el.word} word={el.word} path={el.path} passUpPathRemoved={passUpPathRemoved} passUpPathHovered={passUpPathHovered}/>\r\n                })}\r\n            </div>\r\n        </SearchWrap>\r\n    )\r\n}\r\n\r\nexport default WordSearch\r\n","import React, {useState, useEffect} from 'react'\r\n\r\nfunction LoadingScreen({srcSize}) {\r\n    const [dots, setDots] = useState('')\r\n    const [loadingProg, setLoadingProg] = useState(0)\r\n\r\n    useEffect(() => {   \r\n        document.addEventListener('loadPush', progLoader, false)\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n      console.log(loadingProg, 'LOADING PROG')\r\n    }, [loadingProg])\r\n\r\n    useEffect(() => {\r\n        adder(dots.length)\r\n    }, [dots])\r\n\r\n    const progLoader = async() => {\r\n        console.log('PROG LOADER CALLED')\r\n        setLoadingProg(prevProg => {\r\n            return prevProg + (100/srcSize)\r\n        })\r\n        await new Promise((resolve) => setTimeout(resolve, 350));\r\n    }\r\n\r\n    const adder = (dotLength) => {\r\n        const timeout = setTimeout(() => {\r\n            switch(dotLength){\r\n                case 0:\r\n                    setDots('.')\r\n                    break\r\n                case 1:\r\n                    setDots('..')\r\n                    break\r\n                case 2:\r\n                    setDots('...')\r\n                    break\r\n                default:\r\n                    setDots('')\r\n                    break\r\n            }\r\n        }, 500)\r\n    }\r\n\r\n    return (\r\n        <div className='loader-sec'>\r\n           <h2>Loading...</h2>\r\n           <div className=\"loader-bar\">\r\n               <div className=\"loader-thumb\" style={{width: `${loadingProg}%`}}></div>\r\n               <h3 className=\"loader-num\">{loadingProg}%</h3>\r\n           </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default LoadingScreen\r\n","import './App.css';\r\nimport {appExec, wordSearch, displayResults, clearPreviousWords, appConfig, genGrid} from './scripts/wizard.js';\r\nimport {genStart} from '../src/helpers/appStart.js'\r\nimport AppWrap from './components/AppWrap';\r\nimport AppInfo from './components/AppInfo';\r\nimport WordSearch from './components/search-box/WordSearch'\r\nimport LoadingScreen from './components/LoadingScreen';\r\nimport {useState, useEffect} from 'react'\r\n\r\nfunction App() {\r\n\r\n  const [genReady, setGenReady] = useState(false)\r\n  // sets the size of the grid to 16 tiles (4x4)\r\n  const [srcSize, setSrcSize] = useState(16)\r\n  const [letters, setLetters] = useState()\r\n  const [wordRes, setWordRes] = useState()\r\n  const [loader, setLoader] = useState(false)\r\n  const [loadingProg, setLoadingProg] = useState(0)\r\n\r\n  // on component mount, execute the appCondig function in wizard.js\r\n  // this prepares the game dictionary and arrays of words\r\n  useEffect(() => {\r\n    appConfig() \r\n  }, [])\r\n\r\n  const readySetter = (ready, letters) => {\r\n    if(ready){\r\n      setGenReady(true)\r\n      setLetters(letters)\r\n     } else{\r\n      setGenReady(false)\r\n     }\r\n  }\r\n\r\n  const genStart = async() => {\r\n\r\n    const letterMatrix = await genGrid(srcSize, letters)\r\n    //start the loading screen overlay\r\n    setLoader(true)\r\n\r\n    //clear previous word resposne array\r\n    clearPreviousWords()\r\n\r\n    //begin a word search loop where each search starts with a letter in the 2d array\r\n    for(let i = 0; i < letterMatrix.length; i++){\r\n      for(let j = 0; j < letterMatrix[0].length; j++){\r\n          let path = [{letter: letterMatrix[i][j], row: i, col: j}]\r\n          wordSearch(path, letterMatrix)\r\n          setLoadingProg(prevProg => {return prevProg + (100/srcSize)})\r\n          await new Promise((resolve) => setTimeout(resolve, 350));\r\n      }\r\n    }\r\n\r\n    //get the word response array and display it\r\n    const words = displayResults()\r\n    setWordRes(words)\r\n\r\n    //turn off loader\r\n    setLoader(false)\r\n    setLoadingProg(0)\r\n  }\r\n\r\n  return (\r\n    <AppWrap loader={loader}>\r\n      {/* loading screen overlay */}\r\n      {loader && <LoadingScreen srcSize={srcSize} loadingProg={loadingProg}/>}\r\n\r\n      {/* landing page text and button that starts the search */}\r\n      <AppInfo genReady={genReady} genStart={genStart}/>\r\n\r\n      {/* word search box that needs to be populated with letters before starting game */}\r\n      <WordSearch srcSize={srcSize} readySetter={readySetter} wordRes={wordRes}/>\r\n    </AppWrap>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);"],"sourceRoot":""}